---
title: 博客时间线的生成
date: 2021-07-02 20:33:33
author: RuiLin Dong
permalink: /read/20210702083333
categories:
  - JavaScript
tags:
  - JavaScript
---

关于博客时间线的生成，当时也是找了很多解决方法，不过没有找到比较合适的好的解决方案，以本博客(VuePress) 为例，你要处理的文章的数据格式很可能是这样的：
```JavaScript
export let testPage = [
    {
      "title": "ES6面向对象",
      "frontmatter": {
        "title": "ES6面向对象",
        "date": "2021-02-22T10:35:43.000Z",
        "permalink": "/read/b1af5cb8996363c5",
        "categories": [
          "前端",
          "JavaScript文章"
        ],
      },
      "lastUpdated": "6/6/2021, 9:05:04 PM"
    },
    {
      "title": "ES6面向对象",
      "frontmatter": {
        "title": "ES6面向对象",
        "date": "2020-02-22T10:35:43.000Z",
        "permalink": "/read/b1af5cb8996363c5",
        "categories": [
          "前端",
          "JavaScript文章"
        ],
      },
      "lastUpdated": "6/6/2020, 9:05:04 PM"
    },
    {
      "title": "ES6面向对象",
      "frontmatter": {
        "title": "ES6面向对象",
        "date": "2019-02-22T10:35:43.000Z",
        "permalink": "/read/b1af5cb8996363c5",
        "categories": [
          "前端",
          "JavaScript文章"
        ],
      },
      "lastUpdated": "6/6/2019, 9:05:04 PM"
    }
  ]
```
我这里想到的解决方案是用了 Map 这个数据类型，因为它的 Key Value 以及对应的 API 可以比较方便的存储，首先遍历一次目标对象，将年份时间提取出来作为 Map 的 Key ，然后再进行一次遍历，把年份与 Key 相同的 push 到对应的 Value 数组中。


```JavaScript
/**
 * 获取时间线map
 * 
 * @param {*} pages 
 * @returns 时间线map
 */
export const getTimeLines = (pages) => {
  let resultArr = new Map()
  let upDated = []
  const articles = timeSort(filterConfigMd(pages))
  //获得更新过的文章，并且将文章覆盖的年份给map
  articles.forEach(item => {
    if (item.frontmatter.date) {
      item.frontmatter.formatDate = moment(item.frontmatter.date)
        .subtract(moment().utcOffset() / 60, "hours")
        .format("YYYY-MM-DD")
      upDated.push(item)
      let time = new Date(item.frontmatter.date)
      let year = time.getFullYear()
      if (!resultArr.has(year) && typeof year === 'number') {
        resultArr.set(year, [])
      }
    }
  })
  //如果key相同则push到对应的数组
  upDated.forEach(item => {
    let time = new Date(item.frontmatter.date)
    let year = time.getFullYear()
    resultArr.get(year).push(item)
  })
  return resultArr
}
```

这样，我们就可以将生成一个这样的数据:

```JavaScript
[
    {
        "key": 2021,
        "value": [
            {
                "title": "ES6面向对象",
                "frontmatter": {
                    "title": "ES6面向对象",
                    "date": "2021-02-22T10:35:43.000Z",
                    "permalink": "/read/b1af5cb8996363c5",
                    "categories": [
                        "前端",
                        "JavaScript文章"
                    ],
                    "formatDate": "2021-02-22"
                },
                "lastUpdated": "6/6/2021, 9:05:04 PM"
            }
        ]
    },
    {
        "key": 2020,
        "value": [
            {
                "title": "ES6面向对象",
                "frontmatter": {
                    "title": "ES6面向对象",
                    "date": "2020-02-22T10:35:43.000Z",
                    "permalink": "/read/b1af5cb8996363c5",
                    "categories": [
                        "前端",
                        "JavaScript文章"
                    ],
                    "formatDate": "2020-02-22"
                },
                "lastUpdated": "6/6/2020, 9:05:04 PM"
            }
        ]
    },
    {
        "key": 2019,
        "value": [
            {
                "title": "ES6面向对象",
                "frontmatter": {
                    "title": "ES6面向对象",
                    "date": "2019-02-22T10:35:43.000Z",
                    "permalink": "/read/b1af5cb8996363c5",
                    "categories": [
                        "前端",
                        "JavaScript文章"
                    ],
                    "formatDate": "2019-02-22"
                },
                "lastUpdated": "6/6/2019, 9:05:04 PM"
            }
        ]
    }
]
```
这样就可以很方便的通过 Array.map 或 V-for 等遍历生成对应的 DOM 结构了。

-- 至此完 --